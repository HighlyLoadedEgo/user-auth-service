# Backend Lynx

## Разделы документации

- [Запуск приложения](#запуск-приложения)
- [Руководство Git-commit](#руководство-git-commit)
- [Архитектура приложения](#архитектура-приложения)

## Запуск приложения
> Переименовать .env.local.example -> .env
### Запуск приложения в docker-compose
```bash
docker compose up
```
### Запуск проекта локально
> Предварительно создать и активировать venv
>> Поднять все необходимые сервисы в docker и настроить .env
```bash
pip install poetry
poetry install
pre-commit install
```
```bash
python -O main.py
```
## Руководство Git-commit
### Формат коммита
```
{type}({scope}): {subject}
```
### Правила для коммитов

#### Разрешенные типы - {types}
- `feat` -> новая функциональность
- `fix` -> исправление ошибок
- `docs` -> документация
- `style` -> форматирование, вещи связанные с линтингом
- `refactor` -> реструктуризация кода без изменения внешнего поведения
- `test` -> добавление отсутствующих тестов
- `chore` -> техническое обслуживание
- `init` -> инициальный коммит
- `rearrange` -> файлы перемещены, добавлены, удалены и т.д.
- `update` -> обновление кода (версии, совместимость библиотек)
#### Область - {scope}
Где было сделано изменение (например, файл, компонент, пакет).
> Это может быть что угодно, указывающее место изменения коммита, например, контроллер, клиент, логгер и т.д.
### Тело сообщения - {body}
Здесь даются подробности о коммите, включая:

- мотивация для изменения (сломанный код, новая функция и т.д.)
- сравнение с предыдущим поведением

Некоторые правила для тела сообщения:

Должно быть в настоящем времени.
- Должно быть повелительным наклонением.
- Строки должны быть менее 80 символов в длину.

### Пример

```
fix(users): fix bug in user repository.
```

## Архитектура приложения
Наше приложение построено с использованием модульной структуры, обеспечивающей четкое разделение обязанностей и удобство в расширении функционала. Взаимодействие между модулями установлено по принципу иерархии и зависимостей:
- `application`: Центральный модуль, который отвечает за инициализацию API, настройку конечных точек и интеграцию настроек сервера uvicorn. Этот модуль имеет доступ ко всем остальным модулям и служит точкой входа в приложение.
- `core`: Модуль 'core' служит основой для всего приложения, содержа в себе общие настройки, подключения к базам данных и брокерам сообщений, конфигурацию логирования, а также общие ошибки и константы. Модули `modules` и `application` могут обращаться к core для доступа к общим ресурсам и утилитам.
- `modules`: Здесь реализована бизнес-логика, связанная с отдельными сущностями приложения. Модуль 'modules' включает UseCases, DTOs, специфические ошибки сущностей и другие компоненты бизнес-логики. Этот модуль может взаимодействовать с `core` и `config` для получения необходимых настроек и ресурсов.
- `config`: Модуль 'config' отвечает за извлечение и управление настройками конфигурации из переменных окружения. Это делает его доступным для всех других модулей, которые могут требовать этих настроек для своей работы. Модуль `config` не обращается к другим модулям, выполняя роль поставщика конфигурационных данных.
>Таким образом, модули application и modules могут активно использовать ресурсы core и config, в то время как core и config предоставляют необходимые ресурсы без прямого обращения к другим модулям. Эта структура предоставляет гибкую систему управления зависимостями и облегчает масштабирование приложения.
